;; test builtins and special forms

;; --- quote ---

'x
=> x
'3
=> 3
'()
=> ()
'(x y z)
=> (x y z)

;; --- define ---

(define x 42)
x
=> 42

(define (inc x)
  (+ x 1))
(inc 5)
=> 6
(define (foo x y)
  (+ x 1)
  (+ y 1))
(foo 5 6)
=> 7

;; --- lambda ---

(define inc 
  (lambda (x) (+ x 1)))
(inc 33)
=> 34

;; lambda with multiple expressions in body
(define foo
  (lambda (x y)
    x y))
(foo 9 10)
=> 10

;; --- do ---

(do 1 2 3)
=> 3
(do (+ 1 2) (+ 3 4))
=> 7

;; TODO: DO with side effects

;; --- simple IF constructs --

(if true 1 2)
=> 1
(if false 1 2)
=> 2
(if true (+ 1 1) (+ 2 2))
=> 2
(if false (+ 1 1) (+ 2 2))
=> 4

;; --- eq? ---

(eq? 1 1)
=> false
(eq? true true)
=> true
(eq? () ())
=> true
(eq? '(1 2 3) '(1 2 3))
=> false

;; --- equal? ---

(equal? 1 1)
=> true
(equal? 'x 'x)
=> true
(equal? 'y 'Y)
=> true
(equal? "hello" "hello")
=> true

;; --- cond ---

(cond 
  (false 1)
  (true (+ 1 2))
  (false 4))
=> 3

(cond
  ((equal? 3 4) 100)
  ((equal? 5 6) 101)
  (else 102))
=> 102

;; no condition is true here
(cond
  (false 200))
=> false

;; multiple expressions per condition
(cond
  (true 1 2 3)
  (false 4 5 6)
  (else 7 8 9))
=> 3

;; --- let ---

(let () 1)
=> 1
(let (a 1) 2)
=> 2
(let (a 1) a)
=> 1
(let (a 1) (+ a 1))
=> 2
(let (a 1 b 2) (+ a 1))
=> 2
(let (a 1 b (+ a 1)) (+ a 1))
=> 2
(let (a 1 b (+ a 1)) (+ b 1))
=> 3

(let (a 1)
  (let (b 2)
    (+ a b)))
=> 3

(let (a 1 b 2)
  (let (b 3 c 4)
    (+ a b c)))
=> 8

;; --- macros ---

(define m 
  (macro (x) (+ x 1)))
(macro? m)
=> true

