;; test builtins and special forms

;; --- quote ---

'x
=> x
'3
=> 3
'()
=> ()
'(x y z)
=> (x y z)

;; --- define ---

(define x 42)
x
=> 42

(define (inc x)
  (+ x 1))
(inc 5)
=> 6
(define (foo x y)
  (+ x 1)
  (+ y 1))
(foo 5 6)
=> 7

;; --- lambda ---

(define inc 
  (lambda (x) (+ x 1)))
(inc 33)
=> 34

;; lambda with multiple expressions in body
(define foo
  (lambda (x y)
    x y))
(foo 9 10)
=> 10

;; --- do ---

(do 1 2 3)
=> 3
(do (+ 1 2) (+ 3 4))
=> 7

;; TODO: DO with side effects

;; --- simple IF constructs --

(if true 1 2)
=> 1
(if false 1 2)
=> 2
(if true (+ 1 1) (+ 2 2))
=> 2
(if false (+ 1 1) (+ 2 2))
=> 4

;; --- eq? ---

(eq? 1 1)
=> false
(eq? true true)
=> true
(eq? () ())
=> true
(eq? '(1 2 3) '(1 2 3))
=> false

;; --- equal? ---

(equal? 1 1)
=> true
(equal? 'x 'x)
=> true
(equal? 'y 'Y)
=> true
(equal? "hello" "hello")
=> true

;; --- cond ---

(cond 
  (false 1)
  (true (+ 1 2))
  (false 4))
=> 3

(cond
  ((equal? 3 4) 100)
  ((equal? 5 6) 101)
  (else 102))
=> 102

;; no condition is true here
(cond
  (false 200))
=> false

;; multiple expressions per condition
(cond
  (true 1 2 3)
  (false 4 5 6)
  (else 7 8 9))
=> 3

;; --- let ---

(let () 1)
=> 1
(let (a 1) 2)
=> 2
(let (a 1) a)
=> 1
(let (a 1) (+ a 1))
=> 2
(let (a 1 b 2) (+ a 1))
=> 2
(let (a 1 b (+ a 1)) (+ a 1))
=> 2
(let (a 1 b (+ a 1)) (+ b 1))
=> 3

(let (a 1)
  (let (b 2)
    (+ a b)))
=> 3

(let (a 1 b 2)
  (let (b 3 c 4)
    (+ a b c)))
=> 8

;; --- environments ---

(type-name (type (current-env)))
=> env
(eq? (current-env) (current-env))
=> true
(env-get (current-env) '+)
=> #<+>
(env-get (current-env) 'bogus 33)
=> 33

(env-has? (global-env) 'cadr)
=> true
(env-has? (global-env) 'bogus-does-not-exist)
=> false
(env-has? (builtin-env) '+)
=> true
(env-has? (builtin-env) 'bogus-does-not-exist)
=> false

;; --- apply ---

(apply + '(1 2 3))
=> 6
;; make sure rest args are handled correctly
(apply list '(4 5 6))
=> (4 5 6)
(define d (make-dict "a" 1 "b" 2))
(apply dict-get (list d "c" 3))
=> 3
;; TODO: make sure keyword args are handled correctly

;; APPLY works on macros as well
(define test-when
  (macro (cond body) 
    (list 'if cond body false)))
(apply test-when '(a b))
=> (if a b false)

;; --- function introspection ---

(function-args list)
=> ()
(function-args cadr)
=> (x)
(define (f x y z)
  (+ x y z))
(function-args f)
=> (x y z)

(define (f x y z)
  (+ x y z))
(function-body f)
=> ((+ x y z))
;; test variable names that are the same as special form names (like COND)
;; this is not recommended, but should not cause an error per se (see issue #58)
(define my-when
  (lambda (cond body)
    (list 'if cond body)))
(function-body my-when)
=> ((list (quote if) cond body))

;; --- not ---

(not 3)
=> false
(not false)
=> true
(not true)
=> false
(not (eq? true true))
=> false

;; --- eval-raw ---

(eval-raw '(+ 1 2))
=> 3
(let (plus +)
  (eval-raw '(plus 2 3)))
=> 5
(let (+ (lambda (x y) 0))  ;; fake +
  (eval-raw '(+ 3 4) (global-env)))  ;; but we use the global env
=> 7

;; --- eval (does macroexpansion) ---

(eval '(+ 1 2) (current-env))
=> 3
(let (plus +)
  (eval '(plus 2 3) (current-env)))
=> 5
(let (+ (lambda (x y) 0))  ;; fake +
  (eval '(+ 3 4) (global-env)))  ;; but we use the global env
=> 7
;; assume WHEN exists
(let (x 1)
  (eval '(when x 3) (current-env)))
=> 3

