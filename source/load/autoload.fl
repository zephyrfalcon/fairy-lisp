;; -*- mode: Scheme; -*-
;; automatically loaded

(define cadr
  (lambda (x) (car (cdr x))))
(define cdar
  (lambda (x) (cdr (car x))))
(define caar
  (lambda (x) (car (car x))))
(define cddr
  (lambda (x) (cdr (cdr x))))
(define (caddr x)
  (car (cdr (cdr x))))
(define (cdddr x)
  (cdr (cdr (cdr x))))
(define (cadar x)
  (car (cdr (car x))))

;; --- macro expansion ---

;; if the given expression is a macro expression, expand it exactly once.
;; return a list (new-expr true) if expansion succeeded, (old-expr false)
;; otherwise.
(define (macroexpand-1 expr env)
  (if (pair? expr)
      (if (symbol? (car expr))
          (let (m (env-get env (car expr) false))
            (if m
                (if (macro? m)
                    (list (apply m (cdr expr)) true)  ;; TODO: allow kwargs?
                    (list expr false))
                (list expr false)))
          (list expr false))
      (list expr false)))

;; like MACROEXPAND-1, but expand the macro expression as many times as possible.
;; return the resulting expression.
(define (macroexpand-all expr env)
  (let (result (macroexpand-1 expr env))
    (if (cadr result)  ;; if a macro was expanded, try again
        (macroexpand-all (car result) env)
        (car result))))

;; a version of MACROEXPAND for forms like DEFINE and SET!.
(define (_macroexpand-define expr env)
  (cons (first expr)
        (cons (second expr)
              (map (lambda (subexpr) (macroexpand subexpr env))
                   (cddr expr)))))

(define (_macroexpand-do expr env)
  (cons (first expr)
        (map (lambda (subexpr) (macroexpand subexpr env))
             (cdr expr))))

;; (LET (name1 expr1 name2 expr2 ...) exprs...)
;; in the second part, only evaluate elems 2, 4, 6, ...
;; also evaluate parts 3 and up
(define (_macroexpand-let expr env)
  (let (expand      (lambda (e) (macroexpand e env))
        dont-expand (lambda (e) e))
    (cons (first expr)
          (cons (map-alternate dont-expand expand (second expr))
                (map (lambda (subexpr) (macroexpand subexpr env))
                     (cddr expr))))))

;; (COND (c1 e1) (c2 e2) (else eN))
;; all of these should be expanded, except the ELSE...
;; and things like (c1 e1) should NOT be considered one function call.
;; also, note that there can be multiple expressions after a condition.
(define (_macroexpand-cond expr env)
  (cons (first expr)
        (map (lambda (part) (_macroexpand-cond-part part env))
             (cdr expr))))
(define (_macroexpand-cond-part part env)
  ;; must have at least two parts
  (let (condition (car part)
        clauses (cdr part))
    (cons (if (equal? condition 'else)
              condition
              (macroexpand condition env))
          (map (lambda (subexpr) (macroexpand subexpr env)) clauses))))

(define (macroexpand expr env)
  (if (pair? expr)
      (let (sym (car expr))
        (cond
         ;; handle special forms
         ((equal? sym 'quote) expr)
         ((equal? sym 'define) (_macroexpand-define expr env))
         ((equal? sym 'set!) (_macroexpand-define expr env))
         ((equal? sym 'lambda) (_macroexpand-define expr env))
         ((equal? sym 'macro) (_macroexpand-define expr env))
         ((equal? sym 'do) (_macroexpand-do expr env))
         ((equal? sym 'let) (_macroexpand-let expr env))
         ((equal? sym 'cond) (_macroexpand-cond expr env))
         (else  ;; not a special form
          (let (expr-2 (macroexpand-all expr env))
            (if (pair? expr-2) ;; form does not always stay a list!
                (cons (car expr-2)
                      (map (lambda (subexpr) (macroexpand subexpr env))
                           (cdr expr-2)))
                expr-2)))))
      expr))

;; FIXME: env should be optional (get caller env if not given)
(define (eval expr env)
  (let (expanded-expr (macroexpand expr env))
    (eval-raw expanded-expr env)))

;; ---

(define (first x) (car x))
(define (second x) (cadr x))
(define (third x) (caddr x))

(define (list) %rest)

(define (not x)
  (if x false true))

;; --- type predicates ---

;; NOTE: later, when we have a symbol cache, use EQ?

(define (pair? x)
  (equal? (type-name (type x)) 'pair))
(define (string? x)
  (eq? (type-name (type x)) 'string))
(define (symbol? x)
  (equal? (type-name (type x)) 'symbol))
(define (nil? x)
  (equal? (type-name (type x)) 'nil))
(define (macro? x)
  (equal? (type-name (type x)) 'macro))
(define (keyword? x)
  (equal? (type-name (type x)) 'keyword))
(define (list? x)  ;; XXX rewrite once we have OR... >.>
  (cond ((pair? x) true)
        ((nil? x) true)
        (else false)))
;; NOTE: does not work for supertypes
;; add & use something like IS-INSTANCE-OF? instead!

;; --- higher-order functions like MAP, FILTER, etc ---

(define (_map-aux f lst acc)
  (if (nil? lst)
      (reverse acc)
      (_map-aux f (cdr lst) (cons (f (car lst)) acc))))

(define (map f lst)
  (_map-aux f lst ()))

(define (_map-alternate-aux f g lst f? acc)
  (if (nil? lst)
      (reverse acc)
      (let (func (if f? f g))
        (_map-alternate-aux f g (cdr lst) (not f?)
                            (cons (func (car lst)) acc)))))

;; like MAP, but apply F and G alternately to the elements we're processing.
;; e.g. (1 2 3 4) => ((f 1) (g 2) (f 3) (g 4) ...)
(define (map-alternate f g lst)
  (_map-alternate-aux f g lst true ()))

;; NOTE: Any code involved in expanding macros (directly or indirectly), should
;; be defined above this line.

;; MACROS ARE "TURNED ON" HERE 
(set! *macroexpand-hook* macroexpand)

;; helper function: take a list of expressions; if there are multiple ones,
;; wrap them in a DO construct; otherwise return just the single expression.
;; to be used for macros that may take multiple expressions (like WHEN).
(define (_make-one-expr exprs)
  (if (> (length exprs) 1)
      (cons 'do exprs)
      (car exprs)))

(define when
  (macro (cond expr)
    (let (body (_make-one-expr (cons expr %rest)))
      (list 'if cond body false))))

(define define-macro
  (macro (header expr)
    (let (body (_make-one-expr (cons expr %rest))
          macro-name (car header)
          macro-args (cdr header))
      (list 'define macro-name
            (list 'macro macro-args body)))))
      
(define-macro (or)
  (let (num-args (length %rest))
    (cond
     ((= num-args 0) false)
     ((= num-args 1) (car %rest))
     (else
      (let (name (gensym))
        (list 'let (list name (car %rest))
              (list 'if name name (cons 'or (cdr %rest)))))))))

(define-macro (and)
  (let (num-args (length %rest))
    (cond
     ((= num-args 0) true)
     ((= num-args 1) (car %rest))
     (else
      (list 'if (car %rest) (cons 'and (cdr %rest)) false)))))

;; define system directories
(define *lisp-prelude-path*
  (path-join (list (get-dir-part (get-executable)) "source" "load")))
(define *lisp-test-path*
  (path-join (list (get-dir-part (get-executable)) "source" "tests")))
(define *lisp-library-path*
  (path-join (list (get-dir-part (get-executable)) "source" "lib")))

(define (include filename)
  (let (contents (read-file-as-string filename))
    (eval-string contents %caller-env)))

;; (include (path-join *lisp-prelude-path* "stuff.fs"))

;; TODO: allow default?
(define (module-get mod name)
  (env-get (module-env mod) name))
(define (module-set! mod name value)
  (env-set! (module-env mod) name value))
(define (module-names mod)
  ;; only return the names defined in the module.
  (env-local-names (module-env mod)))

(define (module-get*)
  (cond ((= (length %rest) 2)
         (module-get (first %rest) (second %rest)))
        ((> (length %rest) 2)
         (let (mod (module-get (first %rest) (second %rest)))
           (apply module-get* (cons mod (cddr %rest)))))
        (else (error "MODULE-GET*: must have at least two arguments"))))

;; XXX if this is going to be part of the macro expansion, then AND might
;; not be defined yet... :(
;(define (module-accessor-form? form)
;  (and (symbol? form)
;       (let (s (->string form))
;         (and (not (string-starts-with? s ":"))
;              (not (string-ends-with? s ":"))
;              (string-contains? s ":")))))

;; version of MODULE-ACCESSOR-FORM? that does not use macros.
(define (module-accessor-form? form)
  (if (symbol? form)
      (let (s (->string form))
        (if (string-starts-with? s ":")
            false
            (if (string-ends-with? s ":")
                false
                (string-contains? s ":"))))
      false))

(define (module-accessor-expand form)
  (let (parts (string-split (->string form) ":"))
    (cons 'module-get*
          (cons (string->symbol (first parts))
                (map (lambda (s) (list 'quote (string->symbol s)))
                     (cdr parts))))))

(define (string-join parts)
  (let (sep (if (nil? %rest) "" (first %rest)))
    (%%string-join (map ->string parts) sep)))

(define (conc)
  (string-join %rest))

(define (%%import name)
  (cond ((string? name) (%%import-string name))
        ((symbol? name) (%%import-symbol name))
        (else ...)))

(define (%%import-string filename)
  (let (basename (get-file-base-name filename)
        mod-name (string->symbol basename)
        mod (make-module mod-name)
        code (read-file-as-string filename))
    (eval-string code (module-env mod))
    (env-set! %caller-env mod-name mod)
    mod))

(define (%%import-symbol name)
  ...)

;; eventually: macro: (IMPORT [string | symbol])
