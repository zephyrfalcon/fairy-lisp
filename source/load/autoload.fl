;; -*- mode: Scheme; -*-
;; automatically loaded

(define cadr
  (lambda (x) (car (cdr x))))
(define cdar
  (lambda (x) (cdr (car x))))
(define caar
  (lambda (x) (car (car x))))
(define cddr
  (lambda (x) (cdr (cdr x))))
(define (caddr x)
  (car (cdr (cdr x))))

;; --- macro expansion ---

;; if the given expression is a macro expression, expand it exactly once.
;; return a list (new-expr true) if expansion succeeded, (old-expr false)
;; otherwise.
(define (macroexpand-1 expr env)
  (if (pair? expr)
      (if (symbol? (car expr))
          (let (m (env-get env (car expr) false))
            (if m
                (if (macro? m)
                    (list (apply m (cdr expr)) true)
                    (list expr false))
                (list expr false)))
          (list expr false))
      (list expr false)))

;; like MACROEXPAND-1, but expand the macro expression as many times as possible.
;; return the resulting expression.
(define (macroexpand-all expr env)
  (let (result (macroexpand-1 expr env))
    (if (cadr result)  ;; if a macro was expanded, try again
        (macroexpand-all (car result) env)
        (car result))))

;; test test...
(define when
  (macro (cond body)
    (list 'if cond body false)))

;; ---

(define (first x) (car x))
(define (second x) (cadr x))
(define (third x) (caddr x))

(define list
  (lambda () %rest))

;; --- type predicates ---

;; NOTE: later, when we have a symbol cache, use EQ?

(define pair?
  (lambda (x)
    (equal? (type-name (type x)) 'pair)))
(define symbol?
  (lambda (x)
    (equal? (type-name (type x)) 'symbol)))
(define (nil? x)
  (equal? (type-name (type x)) 'nil))
(define (macro? x)
  (equal? (type-name (type x)) 'macro))

;; --- higher-order functions like MAP, FILTER, etc ---

(define (_map-aux f lst acc)
  (if (nil? lst)
      (reverse acc)
      (_map-aux f (cdr lst) (cons (f (car lst)) acc))))

(define (map f lst)
  (_map-aux f lst ()))

