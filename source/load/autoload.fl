;; -*- mode: Scheme; -*-
;; automatically loaded

(define cadr
  (lambda (x) (car (cdr x))))
(define cdar
  (lambda (x) (cdr (car x))))
(define caar
  (lambda (x) (car (car x))))
(define cddr
  (lambda (x) (cdr (cdr x))))
(define (caddr x)
  (car (cdr (cdr x))))
(define (cdddr x)
  (cdr (cdr (cdr x))))
(define (cadar x)
  (car (cdr (car x))))

;; --- macro expansion ---

;; if the given expression is a macro expression, expand it exactly once.
;; return a list (new-expr true) if expansion succeeded, (old-expr false)
;; otherwise.
(define (macroexpand-1 expr env)
  (if (pair? expr)
      (if (symbol? (car expr))
          (let (m (env-get env (car expr) false))
            (if m
                (if (macro? m)
                    (list (apply m (cdr expr)) true)
                    (list expr false))
                (list expr false)))
          (list expr false))
      (list expr false)))

;; like MACROEXPAND-1, but expand the macro expression as many times as possible.
;; return the resulting expression.
(define (macroexpand-all expr env)
  (let (result (macroexpand-1 expr env))
    (if (cadr result)  ;; if a macro was expanded, try again
        (macroexpand-all (car result) env)
        (car result))))

;; a version of MACROEXPAND for forms like DEFINE and SET!.
(define (_macroexpand-define expr env)
  (cons (first expr)
        (cons (second expr)
              (map (lambda (subexpr) (macroexpand subexpr env))
                   (cddr expr)))))

(define (_macroexpand-do expr env)
  (cons (first expr)
        (map (lambda (subexpr) (macroexpand subexpr env))
             (cdr expr))))

;; (LET (name1 expr1 name2 expr2 ...) exprs...)
;; in the second part, only evaluate elems 2, 4, 6, ...
;; also evaluate parts 3 and up
(define (_macroexpand-let expr env)
  (let (expand      (lambda (e) (macroexpand e env))
        dont-expand (lambda (e) e))
    (cons (first expr)
          (cons (map-alternate dont-expand expand (second expr))
                (map (lambda (subexpr) (macroexpand subexpr env))
                     (cddr expr))))))

;; (COND (c1 e1) (c2 e2) (else eN))
;; all of these should be expanded, except the ELSE...
;; and things like (c1 e1) should NOT be considered one function call.
(define (_macroexpand-cond expr env)
  (cons (first expr)
        (map (lambda (part) (_macroexpand-cond-part part env))
             (cdr expr))))
(define (_macroexpand-cond-part part env)
  ;; must have two parts
  (let (a (first part)
        b (second part))
    (list (if (equal? a 'else)
              a
              (macroexpand a env))
          (macroexpand b env))))

(define (macroexpand expr env)
  (if (pair? expr)
      (let (sym (car expr))
        (cond
         ;; handle special forms
         ((equal? sym 'quote) expr)
         ((equal? sym 'define) (_macroexpand-define expr env))
         ((equal? sym 'set!) (_macroexpand-define expr env))
         ((equal? sym 'lambda) (_macroexpand-define expr env))
         ((equal? sym 'macro) (_macroexpand-define expr env))
         ((equal? sym 'do) (_macroexpand-do expr env))
         ((equal? sym 'let) (_macroexpand-let expr env))
         ((equal? sym 'cond) (_macroexpand-cond expr env))
         (else  ;; not a special form
          (let (expr-2 (macroexpand-all expr env))
            (cons (car expr-2)
                  (map (lambda (subexpr) (macroexpand subexpr env))
                       (cdr expr-2)))))))
      expr))

;; FIXME: env should be optional (get caller env if not given)
(define (eval expr env)
  (let (expanded-expr (macroexpand expr env))
    (eval-raw expanded-expr env)))

;; ---

(define (first x) (car x))
(define (second x) (cadr x))
(define (third x) (caddr x))

(define (list) %rest)

(define (not x)
  (if x false true))

;; --- type predicates ---

;; NOTE: later, when we have a symbol cache, use EQ?

(define (pair? x)
  (equal? (type-name (type x)) 'pair))
(define (symbol? x)
  (equal? (type-name (type x)) 'symbol))
(define (nil? x)
  (equal? (type-name (type x)) 'nil))
(define (macro? x)
  (equal? (type-name (type x)) 'macro))
;; NOTE: does not work for supertypes
;; add & use something like IS-INSTANCE-OF? instead!

;; --- higher-order functions like MAP, FILTER, etc ---

(define (_map-aux f lst acc)
  (if (nil? lst)
      (reverse acc)
      (_map-aux f (cdr lst) (cons (f (car lst)) acc))))

(define (map f lst)
  (_map-aux f lst ()))

(define (_map-alternate-aux f g lst f? acc)
  (if (nil? lst)
      (reverse acc)
      (let (func (if f? f g))
        (_map-alternate-aux f g (cdr lst) (not f?)
                            (cons (func (car lst)) acc)))))

;; like MAP, but apply F and G alternately to the elements we're processing.
;; e.g. (1 2 3 4) => ((f 1) (g 2) (f 3) (g 4) ...)
(define (map-alternate f g lst)
  (_map-alternate-aux f g lst true ()))

;; NOTE: Any code involved in expanding macros (directly or indirectly), should
;; be defined above this line.

;; --- TODO: TURN ON MACROS HERE

(define when
  (macro (cond body)
    (list 'if cond body false)))
